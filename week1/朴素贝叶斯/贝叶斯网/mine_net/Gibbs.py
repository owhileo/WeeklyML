import random
import numpy as np
import pandas as pd
class bayesNode:
    def __init__(self,x,parent,cpt):
        self.x=x
        self.parent=parent 
        self.cpt=cpt   #没有父亲的时候就是一个数字
        self.child=[]

        
    
    def pro(self,event,x_val):
        tmp=[]
        if(self.parent!=''):
            for val in self.parent:
                tmp.append(event[val])
        tmp.append(x_val)
        tmp=tuple(tmp)
        p=self.cpt[tmp]
        return p
        


class bayesNet:
    def __init__(self,node_specs):
        self.nodes=[]
        self.variable=[]
        for var in node_specs:
            node=bayesNode(*var)
            self.variable.append(node.x)
            self.nodes.append(node)
            
            for parent in node.parent:
                if(parent!=''):
                    self.tran2Node(parent).child.append(node)

    

    def tran2Node(self,val):#将val 转化成node
        for node in self.nodes:
            if(node.x==val):
                return node

#gibbs 预测
def Gibbs(x,val_num,evidc,BN,n):#n是迭代的次数 ，x_num 是x可以取值的个数
    count={i:0 for i in range(val_num[x])}  #每个类取值从0开势
    Z=[var for var in BN.variable if var not in evidc] #非证据因子
    # print(Z)
    state=evidc
    print(state)
    for Zi in Z:
        state[Zi]=random.choice(range(val_num[Zi]))  #写成一个字典才好处理
    for j in range(n):#迭代的次数
        for zi in Z:#每一个可以随机游走的属性
            T=[]
            # print((zi))
            for num in range(val_num[zi]):#属性zi的可取的值
                state[zi]=num
                t=BN.tran2Node(zi).pro(state,num)#计算zi和当前状态下zi父节点条件概率
                for y in BN.tran2Node(zi).child:
                    t*=y.pro(state,state[y.x])#计算zi的孩子节点和zi的条件概率
                T.append(t)
            state[zi]=probability(T)#按照一定的分布去根据其概率进行选择
        count[state[x]]+=1
    for key in count:
        count[key]=count[key]/n
    return  count
    

def probability(p):  #以一定的概率去选择去采样
    for i in range(len(p)):
        p[i]=p[i]/np.sum(p)
    for i in range(len(p)):
        if(p[i] > random.uniform(0.0, 1.0)):
            return i
    return random.choice(range(len(p)))
        


#我的输入 （...,0）前面几位代表其父亲节点的取值，最后一位代表当前属性的取值             
BN=bayesNet([ ('A','',{(0,):0.35,(1,):0.58,(2,):0.05}),
             ('B','A',{(0, 0): 0.777, (1, 0): 0.697, (2, 0): 0.673, (0, 1): 0.179, (1, 1): 0.188, (2, 1): 0.265, (0, 2): 0.044, (1, 2): 0.115, (2, 2): 0.061}),
             ('C','B',{(0, 0): 0.988, (1, 0): 0.929, (2, 0): 1.0, (0, 1): 0.012, (1, 1): 0.054, (2, 1): 0.0, (0, 2): 0.0, (1, 2): 0.018, (2, 2): 0.0}),
             ('D','BC',{(0, 0, 0): 0.884, (1, 0, 0): 0.923, (2, 0, 0): 0.974, (0, 1, 0): 0.5, (1, 1, 0): 0.667, (2, 1, 0): 0.001, (0, 2, 0): 0.001, (1, 2, 0): 1.0, (2, 2, 0): 0.001, (0, 0, 1): 0.104, (1, 0, 1): 0.077, (2, 0, 1): 0.013, (0, 1, 1): 0.375, (1, 1, 1): 0.333, (2, 1, 1): 0.001, (0, 2, 1): 0.001, (1, 2, 1): 0.0, (2, 2, 1): 0.001, (0, 0, 2): 0.013, (1, 0, 2): 0.0, (2, 0, 2): 0.013, (0, 1, 2): 0.125, (1, 1, 2): 0.0, (2, 1, 2): 0.001, (0, 2, 2): 0.001, (1, 2, 2): 0.0, (2, 2, 2):0.001}),
             ('E','D',{(0, 0): 0.549, (1, 0): 0.541, (2, 0): 0.9, (0, 1): 0.242, (1, 1): 0.247, (2, 1): 0.1, (0, 2): 0.209, (1, 2): 0.212,(2, 2): 0.0}),
             ('F','CDE',{(0, 0, 0, 0): 0.748, (1, 0, 0, 0): 0.001, (2, 0, 0, 0): 0.001, (0, 1, 0, 0): 0.413, (1, 1, 0, 0): 0.001, (2, 1, 0, 0): 0.001, (0, 2, 0, 0): 0.222, (1, 2, 0, 0): 0.001, (2, 2, 0, 0): 0.001, (0, 0, 1, 0): 0.603, (1, 0, 1, 0): 0.3, (2,0, 1, 0): 0.667, (0, 1, 1, 0): 0.4, (1, 1, 1, 0): 0.333, (2, 1, 1, 0): 0.001, (0, 2, 1, 0): 0.001, (1, 2, 1, 0): 1.0, (2, 2, 1, 0): 0.001, (0, 0, 2, 0): 0.62, (1, 0, 2, 0): 0.001, (2, 0, 2, 0): 0.001, (0, 1, 2, 0): 0.278, (1, 1, 2, 0): 0.001, (2, 1, 2, 0): 0.001, (0, 2, 2, 0): 0.001, (1, 2, 2, 0): 0.001, (2, 2, 2, 0): 0.001, (0, 0, 0, 1): 0.252, (1, 0, 0, 1): 0.001, (2, 0, 0, 1): 0.001, (0, 1, 0, 1): 0.587, (1, 1, 0, 1): 0.001, (2, 1, 0, 1): 0.001, (0, 2, 0, 1): 0.778, (1, 2, 0, 1): 0.001, (2, 2, 0, 1): 0.001, (0, 0, 1, 1): 0.397, (1, 0, 1, 1): 0.7, (2, 0, 1, 1): 0.333, (0, 1, 1, 1): 0.6, (1, 1, 1, 1): 0.667, (2, 1, 1, 1): 0.001, (0, 2, 1, 1): 0.001, (1, 2, 1, 1): 0.0, (2, 2, 1, 1): 0.001, (0, 0, 2, 1): 0.38, (1, 0, 2, 1): 0.001, (2, 0, 2, 1): 0.001, (0, 1, 2, 1): 0.722, (1, 1, 2, 1): 0.001, (2, 1, 2, 1): 0.001, (0, 2, 2, 1): 0.001, (1, 2, 2, 1): 0.001, (2, 2, 2, 1): 0.001}),
             ('G','F',{(0, 0): 0.957, (1, 0): 0.933, (0, 1): 0.036, (1, 1): 0.058, (0, 2): 0.007, (1, 2): 0.01}),
             ('H','DEFG',{(0, 0, 0, 0, 0): 0.86, (1, 0, 0, 0, 0): 0.667, (2, 0, 0, 0, 0): 1.0, (0, 1, 0, 0, 0): 0.646, (1, 1, 0, 0, 0): 0.286, (2, 1, 0, 0, 0): 1.0, (0, 2, 0, 0, 0): 0.854, (1, 2, 0, 0, 0): 0.6, (2, 2, 0, 0, 0): 0.001, (0, 0, 1, 0, 0): 0.413, (1, 0, 1, 0, 0): 0.533, (2, 0, 1, 0, 0): 0.857, (0, 1, 1, 0, 0): 0.013, (1, 1, 1, 0, 0): 0.182, (2, 1, 1, 0, 0): 0.001, (0, 2, 1, 0, 0): 0.097, (1, 2, 1, 0, 0): 0.0, (2, 2, 1, 0, 0): 0.001, (0, 0, 0, 1, 0): 1.0, (1, 0, 0, 1, 0): 0.889, (2, 0, 0, 1, 0): 0.001, (0, 1, 0, 1, 0): 0.001, (1, 1, 0, 1, 0): 1.0, (2, 1, 0, 1, 0): 0.001, (0, 2, 0, 1, 0): 0.001, (1, 2, 0, 1, 0): 0.001, (2, 2, 0, 1, 0): 0.001, (0, 0, 1, 1, 0): 0.833, (1, 0, 1, 1, 0): 0.778, (2, 0, 1, 1, 0): 0.001, (0, 1, 1, 1, 0): 0.001, (1, 1, 1, 1, 0): 0.0, (2, 1, 1, 1, 0): 0.001, (0, 2, 1, 1, 0): 0.0, (1, 2, 1, 1, 0): 0.001, (2, 2, 1, 1, 0): 0.001, (0, 0, 0, 2, 0): 0.001, (1, 0, 0, 2, 0): 1.0, (2, 0, 0, 2, 0): 0.001, (0, 1, 0, 2, 0): 0.001, (1, 1, 0, 2, 0): 0.001, (2, 1, 0, 2, 0): 0.001, (0, 2, 0, 2, 0): 0.001, (1, 2, 0, 2, 0): 0.001, (2, 2, 0, 2, 0): 0.001, (0, 0, 1, 2, 0): 0.001, (1, 0, 1, 2, 0): 1.0, (2, 0, 1, 2, 0): 0.001, (0, 1, 1, 2, 0): 0.001, (1, 1, 1, 2, 0): 0.001, (2, 1, 1, 2, 0): 0.001, (0, 2, 1, 2, 0): 0.001, (1, 2, 1, 2, 0): 0.001, (2, 2, 1, 2, 0): 0.001, (0, 0, 0, 0, 1): 0.14, (1, 0, 0, 0, 1): 0.333, (2, 0, 0, 0, 1): 0.0, (0, 1, 0, 0, 1): 0.354, (1, 1, 0, 0, 1): 0.714, (2, 1, 0, 0, 1): 0.0, (0, 2, 0, 0, 1): 0.146, (1, 2, 0, 0, 1): 0.4, (2, 2, 0, 0, 1): 0.001, (0, 0, 1, 0, 1): 0.587, (1, 0, 1, 0, 1): 0.467, (2, 0, 1, 0, 1): 0.143, (0, 1, 1, 0, 1): 0.987, (1, 1, 1, 0, 1): 0.818, (2, 1, 1, 0, 1): 0.001, (0, 2, 1, 0, 1): 0.903, (1, 2, 1, 0, 1): 1.0, (2, 2, 1, 0, 1): 0.001, (0, 0, 0, 1, 1): 0.0, (1, 0, 0, 1, 1): 0.111, (2, 0, 0, 
1, 1): 0.001, (0, 1, 0, 1, 1): 0.001, (1, 1, 0, 1, 1): 0.0, (2, 1, 0, 1, 1): 0.001, (0, 2, 0, 1, 1): 0.001, (1, 2, 0, 1, 1): 0.001, (2, 2, 0, 1, 1): 0.001, (0, 0, 1, 1, 1): 0.167, (1, 0, 1, 1, 1): 0.222, (2, 0, 1, 1, 1): 0.001, (0, 1, 1, 1, 1): 0.001, (1, 1, 1, 1, 1): 1.0, (2, 1, 1, 1, 1): 0.001, (0, 2, 1, 1, 1): 1.0, (1, 2, 1, 1, 1): 0.001, (2, 2,1, 1, 1): 0.001, (0, 0, 0, 2, 1): 0.001, (1, 0, 0, 2, 1): 0.0, (2, 0, 0, 2, 1): 0.001, (0, 1, 0, 2, 1): 0.001, (1, 1, 0, 2, 1): 0.001, (2, 1, 0, 2, 1): 0.001, (0, 2, 0, 2, 1): 0.001, (1, 2, 0, 2, 1): 0.001, (2, 2, 0, 2, 1): 0.001, (0, 0, 1, 2, 1): 0.001, (1, 0, 1, 2, 1): 0.0, (2, 0, 1, 2, 1): 0.001, (0, 1, 1, 2, 1): 0.001, (1, 1, 1, 2, 1): 0.001, (2, 1, 1, 2, 1): 0.001, (0, 2, 1, 2, 1): 0.001, (1, 2, 1, 2, 1): 0.001, (2, 2, 1, 2, 1): 0.001}) ])

#利用gibbs进行预测：ans是对应（证据因子）位置上的预测结果
D=3
E=3
F=2
G=3
ans={}
i=0
for d in range(3):
    for e in range(3):
        for f in range(2):
            for g in range(3):
                tmp=Gibbs('H',{'A':3,'B':3,'C':3,'D':3,'E':3,'F':2,'G':3,'H':2},{'D':d,'E':e,'F':f,'G':g},BN,10000)
                if(tmp[0]>tmp[1]):
                    ans[(d,e,f,g)]=1
                else:
                    ans[(d,e,f,g)]=0
                i+=1
# print(ans)

# #遍历数据进行验证：
num=0
data = pd.read_csv("titanic_test.csv",sep=',')
for i in range(np.size(data,0)):
    tmp=data.iloc[i,[3,4,5,6]]
    tmp=[i-1 for i in tmp]
    tuple_tmp=tuple(tmp)
    if(int(ans[tuple_tmp])==int(data.iloc[i,[7]])):
        num+=1

print("accuracy:{}".format(num/np.size(data,0)))

       
# print(data.iloc[0,[2,3,4]])
